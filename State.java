/*
Eurolfan, Jan Ellis D.
2010 - 29160
CMSC 170 U-7L
Exer 2 - 8 Puzzle Solver using A* Search

State.java
	A class that represents a state in 8 Puzzle
*/

public class State
{
	int f, g, h;
	int [][] board;
	State parent;

	// constructor for states that are generated by the ResultGenerator
	public State (int [][] board, int g, State parent)
	{
		this.board = board;
		this.g = g;
		this.parent = parent;
		setHParam ();
		setFParam ();
	}

	// constructor for the initial state
	public State (int [][] board)
	{
		this.board = board;
		this.g = 0;
		setHParam ();
		setFParam ();
	}

	// computes the F Parameter
	public void setFParam ()
	{
		this.f = this.g + this.h;
	}

	// computes the H Parameter
	public void setHParam ()
	{
		this.h = 0;
		for (int i = 0; i < 3; i++)
		{
			for (int j = 0; j < 3; j++)
			{
				this.h += computeDistance (this.board [i][j], i, j);
			}
		}
	}

	// returns the parent of this state
	public State getParent ()
	{
		return this.parent;
	}

	// returns the H Parameter of this state
	public int getHParam ()
	{
		return this.h;
	}

	// returns the G Parameter of this state
	public int getGParam ()
	{
		return this.g;
	}

	// returns the F Parameter of this state
	public int getFParam ()
	{
		return this.f;
	}

	// returns the 2d int array that represents this state
	public int[][] getBoard ()
	{
		return this.board;
	}

	// returns a certain element of this board
	public int getElement (int i, int j)
	{
		return this.board [i][j];
	}

	// returns true if both states have the same state representation
	public boolean compareState (State state)
	{
		// compare board states
		for (int i = 0; i < 3; i++)
			for (int j = 0; j < 3; j++)
				if (this.board [i][j] != state.board [i][j])
					return false;

		return true;
	}

	// returns true if this G Parameter is less than the state's G Parameter
	public boolean compareGParam (State state)
	{
		return (this.g < state.getGParam ());
	}

	// computes the heuristic (Manhattan Distance) for this state
	private int computeDistance (int value, int currX, int currY)
	{
		int distance = 0;
		switch (value)
		{
			case 0:
				distance = Math.abs (2-currX) + Math.abs (2-currY);
				break;
			case 1:
				distance = Math.abs (0-currX) + Math.abs (0-currY);
				break;
			case 2:
				distance = Math.abs (0-currX) + Math.abs (1-currY);
				break;
			case 3:
				distance = Math.abs (0-currX) + Math.abs (2-currY);
				break;
			case 4:
				distance = Math.abs (1-currX) + Math.abs (0-currY);
				break;
			case 5:
				distance = Math.abs (1-currX) + Math.abs (1-currY);
				break;
			case 6:
				distance = Math.abs (1-currX) + Math.abs (2-currY);
				break;
			case 7:
				distance = Math.abs (2-currX) + Math.abs (0-currY);
				break;
			case 8:
				distance = Math.abs (2-currX) + Math.abs (1-currY);
				break;
		}
		return distance;
	}
}
